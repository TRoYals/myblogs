[{"categories":["Japanese"],"content":"一节课讲完日语动词12种变形_哔哩哔哩_bilibili- 动词变形 辞书型：原型 基本型：包括原型和用言的活用型。 例如：行く（原型）、行ける（可能态）、行かれる（被动态）、行かせる（使役 态）、行かせられる（使役被动态） （注：基本型不包括用 言活用型的过去形式。例如：行った、行かなかった、不属于基本型。） 普通型：即简体 注：动词ます形（即动词连用形），て形，ば形，意志形，不属于动词辞书型，基本型，普通型的范围。 ","date":"2023-04-02","objectID":"/%E6%97%A5%E8%AF%AD%E5%8F%98%E5%BD%A2/:0:0","tags":["language"],"title":"日语变形","uri":"/%E6%97%A5%E8%AF%AD%E5%8F%98%E5%BD%A2/"},{"categories":["Japanese"],"content":"形容词变形 日语-形容词的分类和变形 | Chars’s Blog ","date":"2023-04-02","objectID":"/%E6%97%A5%E8%AF%AD%E5%8F%98%E5%BD%A2/:1:0","tags":["language"],"title":"日语变形","uri":"/%E6%97%A5%E8%AF%AD%E5%8F%98%E5%BD%A2/"},{"categories":["Japanese"],"content":"动词变形 image.png ","date":"2023-04-02","objectID":"/%E6%97%A5%E8%AF%AD%E5%8F%98%E5%BD%A2/:2:0","tags":["language"],"title":"日语变形","uri":"/%E6%97%A5%E8%AF%AD%E5%8F%98%E5%BD%A2/"},{"categories":["Japanese"],"content":"动词分类 一类动词又称为五段动词 一类动词指以あいうえお结尾的动词+ あ・う・お+う的动词+16个特例 五段动词，指的是词尾的五个段都有含义 如何判断一个词是不是五段动词　#card 看是不是る结尾，若不是则不是五段动词 若是る结尾，且あうお结尾的音+る，则为五段动词 16个特例归类为五段动词 特例：16个　汉字 读音 入る はしる 走る はしる 帰る かえる 知る しる 要る いる 切る きる 蹴る ける 減る へる 入る いる 焦る あせる 返る かえる 限る かぎる 茂る しげる 喋る しゃべる 滑る すべる 散る ちる ^1680421347674 二类动词又称为1段动词 必须る结尾 る的前面一个音是い或え结尾（上一段下一段） 16个特例除外 送假名概念 三类动词 カ变（か行） 来る（くる）只有这一个！！！！！（来る 在ka行） サ变（さ行）只有这两个！！！！ する 〜する　勉強する 三类动词 练习 ある　是一类动词 いる（居る）一般默认为居る　为二类 而　要る入る为一类 始まる　是一类动词 終わる　是一类动词 作る（つくる）是一类动词（う） 食べる（たべる）二类动词 （え） ### 动词变化 あ い う え お 其他 12个形式 被｜未｜使｜使被 礼 原 命｜假｜可 意 て/た 记忆方法 被喂屎啊 ます 原型 名夹克诶 哟(Yio) て・た形变化 一类动词 口诀： 姑哭姨爹帖，五次露出，母不怒，是喜帖 ぐくいでて、うつる促、むぶぬ（んで）、す**して 行く→行って　特例 二类动词 る＋て 三类动词 くる→きて する→して あ变化 $V_{b,w,s,sb}$ 注意，这里う→わ　被动 被动（あ）れる、られる、こられる、される 一类、二类、ka变、sa变 举例： 違う→違われる　ある→わられる　いる→いられる　未然/否定/ない (あ)ない、ない、こない、しない 特例：ある→ない（不要变成别的） 变成ない后词可以动词化，看作一类动词 使役 （あ）せる、させる、こさせる、させる 举例： いる→いさせる　ある→あらせる　始まる→始まらせる　終わる→終わらせる　くる→こさせる　いく→行かせる　食べる→食べさせる 使役被动(一番難しい) 先变成使役（把一个动词变成二类动词），再按二类的方法变成被动（せる→せられる),如果せら的前面没有さ的音，则把せら约音成さ 使役被动有约音 举例：ちがう→違わされる　話す→話させられる ある→あらされる　いる→いさせられる　見学する→見学させられる　始まる→始まらされる　くる→来させられる　いく→いかされる　帰る→帰らさせる　する→させられる　食べる→食べさせられる　飲む→飲まされる　働く→働かされる　読む→読まさせる 書く→書かされる　作る→作らされる え变化 $V_{mjk}$ 命令形 一エ二ロ三こい、しろ才是命令形 （え）、ろ、こい、しろ 举例： 違う→違え　ある→あれ　いる→いろ　始まる→始まれ　見学する→見学しろ　くる→こい　いく→いけ　帰る→帰れ　働く→働け　飲む→飲め 死ぬ→死ね　する→しろ　食べる→食べろ　書く→書け 假定形｜条件形｜ば形 ☒ 假定四大天王？ ✅ 2022-07-06 假定えば・ければ 假定 一类形容词 Aい→Aければ　行く→行かない→行かなければ 二类形容词/名词　であれば｜ならば｜なら （え）ば、れば、くれば、すれば 举例： 違う→違えば　ある→あれば　くる→来れば　いく→行けば　始まる→始まれば　飲む→飲めば　読む→読めば 可能形(可以能够) 注意和被动区分 える｜られる｜こられる｜できる （え）る、られる、こられる、できる 举例：違う→違える　ある→あれる　いる→いられる　見学する→見学できる 始まる→始まれる　終わる→終われる　くる→来られる　行く→いける する→できる　飲む→飲める　働く→働ける　書く→書ける　作る→作れる お变化 意志形 和命令形对比！！！！ （お）う、よう、こよう、しよう 注意： 帰ろう是意志形 食べろ是命令形 食べよう是意志形（不要把ろ记混了） 举例： 違う→違おう　ある→あろう　いる→いよう　くる→こよう　いく→いこう　〜する→〜しよう　始まる→始まろう　終わる→終わろう　帰る→帰ろう　勉強する→勉強しよう　働く→働こう 待つ→待とう　（让我们等） 待て（等一下） ","date":"2023-04-02","objectID":"/%E6%97%A5%E8%AF%AD%E5%8F%98%E5%BD%A2/:2:1","tags":["language"],"title":"日语变形","uri":"/%E6%97%A5%E8%AF%AD%E5%8F%98%E5%BD%A2/"},{"categories":["web"],"content":"一个启发式学习的案例，通过chatGPT | Feature | Session | Cookie | Token | |———|———|——–|——-| |Location | Server-side | Client-side | Client-side | |State | Stateful | Stateless | Stateless | |Lifetime | Expires after a period of inactivity or when the user logs out | Persistent or session-only | Expires after a certain period of time or when manually invalidated | |Usage | Typically used for web applications that require server-side processing and state management | Used for storing user preferences, session data, and other information | Commonly used in web APIs and services | |Security | Can be more secure because the session data is stored server-side and not directly accessible by the client | Can be less secure because the cookie data is stored on the client-side and can be easily accessed or manipulated | Can be secure if properly implemented and validated using cryptographic algorithms | |Storage Size | Can store larger amounts of data than cookies | Limited to a few kilobytes | Can store larger amounts of data than cookies | |Implementation | Typically implemented using server-side technologies like PHP or Node.js | Easily implemented using JavaScript or web frameworks like Express.js or Django | Can be implemented using various programming languages and web frameworks | ","date":"2023-03-29","objectID":"/token-session-cookie-localstroage/:0:0","tags":["chatGPT"],"title":"token session cookie localStroage","uri":"/token-session-cookie-localstroage/"},{"categories":["web"],"content":"give a example to use token as authenation for users login in Sure, here’s an example of how tokens can be used for user authentication in a web application: When a user logs in to the web application with valid credentials, the server generates a unique token for that user and returns it to the client as a response to the login request. The client saves the token locally, typically in local storage or in a cookie, so that it can be accessed and sent back to the server with subsequent requests. For every subsequent request that requires authentication, the client includes the token in the request headers. The server receives the request and validates the token. If the token is valid, the server proceeds with the request and returns the requested resource or data. If the token is invalid or has expired, the server denies the request and returns an error message. Here’s an example of how this might look in code using JSON Web Tokens (JWTs) and the Express.js framework in Node.js: // Import required libraries const jwt = require('jsonwebtoken'); const express = require('express'); // Create a new instance of the Express.js application const app = express(); // Define a secret key for signing JWTs const secretKey = 'mysecretkey'; // Create a route for handling user login requests app.post('/login', (req, res) =\u003e { // TODO: Validate user credentials and generate user object const user = { id: 123, username: 'johndoe' }; // Generate a JWT for the user and send it back to the client const token = jwt.sign({ userId: user.id }, secretKey, { expiresIn: '1h' }); res.json({ user, token }); }); // Create a middleware function for verifying JWTs function verifyToken(req, res, next) { // Get the token from the Authorization header const authHeader = req.headers.authorization; const token = authHeader \u0026\u0026 authHeader.split(' ')[1]; if (!token) { return res.status(401).json({ message: 'Unauthorized' }); } // Verify the token using the secret key jwt.verify(token, secretKey, (err, decoded) =\u003e { if (err) { return res.status(401).json({ message: 'Unauthorized' }); } // Add the user ID to the request object for later use req.userId = decoded.userId; }); } // Create a protected route that requires authentication app.get('/protected', verifyToken, (req, res) =\u003e { // TODO: Return protected data or resources res.json({ message: 'Protected data' }); }); // Start the server app.listen(3000, () =\u003e { console.log('Server listening on port 3000'); }); In this example, the login route generates a JWT for the authenticated user and sends it back to the client along with the user object. The client can then save the token locally and include it in subsequent requests. The verifyToken middleware function checks for the presence of a valid token in the Authorization header and verifies it using the secret key. If the token is valid, the function adds the user ID to the request object, allowing subsequent routes to access it. Finally, the protected route is marked as requiring authentication by including the verifyToken middleware function as a parameter. If a valid token is present, the route returns protected data or resources. ","date":"2023-03-29","objectID":"/token-session-cookie-localstroage/:1:0","tags":["chatGPT"],"title":"token session cookie localStroage","uri":"/token-session-cookie-localstroage/"},{"categories":["web"],"content":"what is next() usage in JS? In JavaScript, next() is commonly used in the context of middleware functions. Middleware functions are functions that are invoked between receiving an HTTP request and sending an HTTP response. These functions have access to the request and response objects and can modify them as necessary. When a middleware function has completed its task, it must call the next() function to pass control to the next middleware function in the chain. If it does not call next(), the request-response cycle will be terminated and the client will never receive a response. For example, in a Node.js Express application, middleware functions are often defined using the app.use() method. Here is an example middleware function that simply logs the URL of the incoming request and passes control to the next middleware function: app.use(function(req, res, next) { console.log(\"Received request for URL: \" + req.url); next(); }); In this example, next() is called at the end of the function to ensure that the request continues to the next middleware function in the chain. ","date":"2023-03-29","objectID":"/token-session-cookie-localstroage/:2:0","tags":["chatGPT"],"title":"token session cookie localStroage","uri":"/token-session-cookie-localstroage/"},{"categories":["web"],"content":"tell me how to use jwt.verify() jwt.verify() is a method provided by the jsonwebtoken package in Node.js, which can be used to verify the authenticity of a JSON Web Token (JWT). Here is an example of how to use jwt.verify(): const jwt = require(\"jsonwebtoken\"); // The JWT to be verified const token = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\"; // The secret key used to sign the JWT const secret = \"my_secret_key\"; // Verify the token jwt.verify(token, secret, (err, decoded) =\u003e { if (err) { console.log(\"JWT verification failed:\", err.message); } else { console.log(\"JWT verified. Decoded payload:\", decoded); } }); In this example, jwt.verify() is used to verify the token against the secret key. If the verification is successful, decoded will contain the decoded payload of the JWT. If the verification fails, err will contain an error message. Note that jwt.verify() can also be used with asynchronous programming. Instead of passing a callback function as the third argument, you can use jwt.verify() as a Promise and use the await keyword: const decoded = await jwt.verify(token, secret); ","date":"2023-03-29","objectID":"/token-session-cookie-localstroage/:3:0","tags":["chatGPT"],"title":"token session cookie localStroage","uri":"/token-session-cookie-localstroage/"},{"categories":["web"],"content":"give me an example use Session Sure! Here is an example of how you could use session in a Next.js API route: import { NextApiRequest, NextApiResponse } from 'next'; import { withSession } from 'next-session'; interface SessionData { isLoggedIn: boolean; userId?: string; } const handler = withSession(async (req: NextApiRequest \u0026 { session?: SessionData }, res: NextApiResponse) =\u003e { const { session } = req; if (!session?.isLoggedIn) { // User is not authenticated, return 401 Unauthorized res.status(401).send('Unauthorized'); return; } // User is authenticated, continue with the request const userId = session.userId; // Do something with the userId, e.g. fetch user data from a database // ... res.status(200).json({ userId }); }); export default handler; In this example, we define an interface SessionData that describes the shape of the session data that we want to store. In this case, we are storing a boolean isLoggedIn flag and an optional userId string. We then define an API route handler function that is wrapped with the withSession higher-order function. Inside this function, we check if the isLoggedIn flag is set in the session data. If it is not set, we return a 401 Unauthorized error response. Otherwise, we continue with the request and extract the userId from the session data. You can use the req.session object to read and write session data. For example, you could set the isLoggedIn flag to true when a user successfully logs in: req.session.isLoggedIn = true; req.session.userId = userId; await req.session.save(); // Save the session data And you could clear the session data when a user logs out: req.session.destroy(); await req.session.save(); // Save the session data Note that we need to call await req.session.save() after making changes to the session data to ensure that the changes are persisted. ","date":"2023-03-29","objectID":"/token-session-cookie-localstroage/:4:0","tags":["chatGPT"],"title":"token session cookie localStroage","uri":"/token-session-cookie-localstroage/"},{"categories":["web"],"content":"is the session and cookie the same thing? No, session and cookie are not the same thing, although they are often used together in web development. A cookie is a small piece of data that is sent from a website to a user’s web browser, and is stored on the user’s computer as a text file. Cookies can be used to remember user preferences and login information, and to track user activity on a website. A session, on the other hand, is a way to store information about a user’s activity on a website on the server-side, rather than on the user’s computer. Sessions are commonly used to keep track of user-specific data and to maintain state across multiple HTTP requests, such as in the case of user authentication or shopping cart functionality. While cookies and sessions are separate concepts, cookies are often used to store a session identifier that can be used to retrieve session data on the server-side. ","date":"2023-03-29","objectID":"/token-session-cookie-localstroage/:5:0","tags":["chatGPT"],"title":"token session cookie localStroage","uri":"/token-session-cookie-localstroage/"},{"categories":["algorithm"],"content":"二叉树递归遍历 略 ## 二叉树迭代法遍历 二叉树 前序迭代遍历 #card 定义一个栈和一个指针cur，初始时cur指向根节点，栈为空。 当cur不为空或者栈不为空时，进行循环： a. 访问cur节点并将其入栈，然后将cur指向其左子节点。 b. 如果cur为空，弹出栈顶节点node并将cur指向node的右子节点。 循环结束后，所有节点均已遍历完毕。 var preorderTraversal = function(root) { let cur = root ; let stack = []; let res = []; while(stack.length||cur){ if(cur){ stack.push(cur) res.push(cur.val); cur = cur.left; }else{ let temp = stack.pop(); cur = temp.right; } } return res }; 二叉树 中序迭代遍历 \\#card 定义一个栈和一个指针cur，初始时cur指向根节点，栈为空。 当cur不为空或者栈不为空时，进行循环： a. 如果cur不为空，将cur入栈，然后将cur指向其左子节点，重复此操作直到cur为空。 b. 如果cur为空，弹出栈顶节点node并访问它，然后将cur指向node的右子节点。 循环结束后，所有节点均已遍历完毕。 let stack = []; stack.push(root) let cur = root; let res = []; while(cur || stack.length){ if(cur.left) { stack.push(cur.left) cur = cur.left }else{ let temp = stack.pop(); res.push(temp.val); cur = temp.right } } return res 二叉树后序迭代遍历 #card 定义一个空栈 stack 和一个空数组 res，以及一个指针 cur 和一个指针 pre，其中 cur 初始指向根节点 root，pre 初始值为 null。 当 cur 不为空或栈不为空时，循环执行以下操作： a. 如果 cur 不为空，将 cur 压入栈中，然后将 cur 指向其左子节点或右子节点，优先遍历左子树。如果 cur 既没有左子节点也没有右子节点，则将 cur 置为空。 b. 如果 cur 为空，则从栈中查询栈顶元素（不是弹出） node，判断该元素的右子节点是否存在且没有被遍历过，如果是，则将 cur 指向它的右子节点；否则，将该元素的值加入到结果数组 res 中，然后将 pre 指向该元素，同时将该元素从栈中弹出。 循环结束后，返回结果数组 res。 var postorderTraversal = function(root) { let stack = []; let cur = root; let res = []; let pre = null while(cur || stack.length){ if(cur){ stack.push(cur) cur = cur.left||cur.right; }else{ let node = stack[stack.length-1];; if(node.right \u0026\u0026 node.right !==pre ){ cur = node.right }else{ res.push(node.val) pre = node; stack.pop() } } } return res }; ","date":"2023-03-25","objectID":"/%E4%BA%8C%E5%8F%89%E6%A0%91/:1:0","tags":["leetcode"],"title":"二叉树","uri":"/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["algorithm"],"content":"二叉树层序遍历 #card 首先创建了一个空数组 res 和一个空队列 queue，将根节点添加到队列中。如果根节点为空，则直接返回空数组 res。 接下来，代码进入一个 while 循环，该循环在队列不为空时一直执行。在循环中，首先获取当前队列的长度，并创建一个空数组 curLevel 用于存储当前层级的节点值。 然后，代码在 for 循环中遍历队列中的节点，并将节点的值添加到 curLevel 数组中。如果节点有左子节点，则将其左子节点添加到队列中；如果节点有右子节点，则将其右子节点添加到队列中。for 循环结束后，将 curLevel 数组添加到 res 数组中，表示当前层级的节点遍历完毕。 最后，当队列为空时，while 循环结束，代码返回 res 数组，其中包含了每个节点所在的层级及其值。　var levelOrder = function(root) { let res = [], queue= []; queue.push(root) if(root === null){ return res; } while(queue.length){ let length = queue.length;\\\\这一步很关键，因为在之后的操作中queue的长度会发生变化！！ let curLevel = []; for(let i = 0;i\u003clength;i++){ let node = queue.shift() curLevel.push(node.val) node.left \u0026\u0026 queue.push(node.left) node.right \u0026\u0026 queue.push(node.right) } res.push(curLevel) } return res }; 同样的模型还可以求最长二叉树/最小 etc ","date":"2023-03-25","objectID":"/%E4%BA%8C%E5%8F%89%E6%A0%91/:2:0","tags":["leetcode"],"title":"二叉树","uri":"/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["algorithm"],"content":"翻转二叉树 var invertTree = function(root) { let res =[],queue = []; if(root ==null)return root queue.push(root) while(queue.length){ let length = queue.length; for(let i =0;i\u003clength;i++){ let node = queue.shift(); let temp =node.right; node.right = node.left; node.left = temp; node.left \u0026\u0026 queue.push(node.left) node.right \u0026\u0026 queue.push(node.right) } } return root }; ","date":"2023-03-25","objectID":"/%E4%BA%8C%E5%8F%89%E6%A0%91/:3:0","tags":["leetcode"],"title":"二叉树","uri":"/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["interview"],"content":"Map #card new Map() —创建map map.set(key,value)—根据键存储值 map.get(key) returns the value by the key. return undefined if key doesn’t exists map.has(key) returns true if key exists, false otherwise map.delete(key) remove elements by key map.clear() removes everything map.size returns the current element count. ^1679408153211 使用object作为map的key会发生什么 let john = { name: \"John\" }; let visitsCountObj = {}; // try to use an object visitsCountObj[john] = 123; #card let john = { name: \"John\" }; let ben = { name: \"Ben\" }; let visitsCountObj = {}; // try to use an object visitsCountObj[ben] = 234; // try to use ben object as the key console.log(visitsCountObj);//{ '[object Object]': 234 } visitsCountObj[john] = 123; console.log(visitsCountObj);//{ '[object Object]': 123 } Objects can be used as a key! ^1679408869940 map的链式调用 #card 每一次map.set的调用会返回本身，我们可以进行链式调用 map.set('1', 'str1') .set(1, 'num1') .set(true, 'bool1'); ^1679408869956 ","date":"2023-03-21","objectID":"/javascript%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98%E5%9F%BA%E7%A1%80/:1:0","tags":["JS"],"title":"JavaScript面试（基础）","uri":"/javascript%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98%E5%9F%BA%E7%A1%80/"},{"categories":["interview"],"content":"map interationsn #card map.keys() -returns an iterable for keys map.values() -returns an iterable for values map.entries() -return an iterable for entries [key,value], it’s used by default in for … of ^1679435632847 Map.forEach用法 #card let recipeMap = new Map([ ['cucumber', 500], ['tomatoes', 350], ['onion', 50] ]); ^1679435632870 // runs the function for each (key, value) pair recipeMap.forEach( (value, key, map) =\u003e { alert(`${key}: ${value}`); // cucumber: 500 etc }); ","date":"2023-03-21","objectID":"/javascript%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98%E5%9F%BA%E7%A1%80/:1:1","tags":["JS"],"title":"JavaScript面试（基础）","uri":"/javascript%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98%E5%9F%BA%E7%A1%80/"},{"categories":["interview"],"content":"object from map how to create a map from object #card use Object.entries(obj) let obj = { name: \"John\", age: 30 }; let map = new Map(Object.entries(obj)); alert( map.get('name') ); // John ^1679436804602 how to create a object from a map #card use Object.fromEntries let map = new Map(); map.set('banana', 1); map.set('orange', 2); map.set('meat', 4); let obj = Object.fromEntries(map.entries()); // make a plain object (*)_ // done! // obj = { banana: 1, orange: 2, meat: 4 } alert(obj.orange); // 2 let obj = Object.fromEntries(map);//the same with previous one ^1679436804609 ","date":"2023-03-21","objectID":"/javascript%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98%E5%9F%BA%E7%A1%80/:1:2","tags":["JS"],"title":"JavaScript面试（基础）","uri":"/javascript%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98%E5%9F%BA%E7%A1%80/"},{"categories":["interview"],"content":"Set the basic methods of Set. #card most are the same with Map new Set([iterable]) set.add(value) set.has(value) set.delete(value) set.size set.clear map.set(key,value) ^1679436804613 interation over Set. set.keys() set.values()(same with set.keys) and set.entries() (returns [value,value]). 把set转换为数组进行数组操作 #card let keys = Array.from(map.keys());　","date":"2023-03-21","objectID":"/javascript%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98%E5%9F%BA%E7%A1%80/:2:0","tags":["JS"],"title":"JavaScript面试（基础）","uri":"/javascript%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98%E5%9F%BA%E7%A1%80/"},{"categories":["interview"],"content":"Variable Scope, Closure ","date":"2023-03-21","objectID":"/javascript%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98%E5%9F%BA%E7%A1%80/:3:0","tags":["JS"],"title":"JavaScript面试（基础）","uri":"/javascript%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98%E5%9F%BA%E7%A1%80/"},{"categories":["interview"],"content":"code blocks the variable declared inside a code block {}, it’s only visible inside that block. ### Lexical Environment variable declares　function declarations when a lexical environment is created, a function Declaration immediately created( that is the reson why we can use a function even before the declaration) Inner and Outer Lexical Environment returning a function 感觉弄的有点麻烦了，实际上只要把下面这个例子记清楚就可以了。 console.log(test); console.log(fn1); var test = 25; function fn1(){ console.log(test); } function fn2(){ var test =35; fn1(); } fn2(); #card js outpus: undefined f fn1(){ XX} 25 前面两个输出是变量声明和函数声明的对比，后面之所以输出25.简要逻辑如下： fn2()中调用fn1()，而fn1()在全局变量声明中，找到fn1()后，fn1()找最近的test，最近的test就是25（全局中） 注意这里的变量是用VAR声明的，只有VAR声明的变量如此，LET声明的变量建议自己去试试 ^1679440647772 ","date":"2023-03-21","objectID":"/javascript%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98%E5%9F%BA%E7%A1%80/:3:1","tags":["JS"],"title":"JavaScript面试（基础）","uri":"/javascript%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98%E5%9F%BA%E7%A1%80/"},{"categories":["interview"],"content":"Sample Question 看看下面这个代码。最后一行代码的执行结果是什么？ let phrase = \"Hello\"; if (true) { let user = \"John\"; function sayHi() { alert(`${phrase}, ${user}`); } } sayHi(); #card 答案:error ，在if中声明的函数也不会被声明。 ^1679441518547 编写一个像 sum(a)(b) = a+b 这样工作的 sum 函数。 是的，就是这种通过双括号的方式（并不是错误）。 #card function sum(a) { function sumb(b) { return a + b; } return sumb; } ^1679441529984 3. 下面的代码输出什么？如果条件中var x=2 换成let x = 2 呢 let x = 1; function func() { console.log(x); // ReferenceError: Cannot access 'x' before initialization var x = 2;//如果换成let x = 2 呢 } func(); #card 输出 undifined. 如果换成 let则输出 error ^1679444622106 通过函数筛选 #card function inBetween(a, b) { function input(number) { if (a \u003c= number \u0026\u0026 b \u003e= number) return 1; else return 0; } return input; } function inArray(arr) { function input(number) { if (number in arr) return 1; else return 0; } return input; } console.log(arr.filter(inBetween(3, 6))); console.log(arr.filter(inArray([1, 2, 10]))); #card function byField(field) { function compare(a, b) { return a.field \u003e b.field ? 1 : -1; } return compare; } ^1679444622116 函数大军　#card 用for循环，或者在while循环里声明i（因为每次while循环都会创造新的词法环境，新的函数要去while循环外的词法环境找i ^1679444622120 ","date":"2023-03-21","objectID":"/javascript%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98%E5%9F%BA%E7%A1%80/:3:2","tags":["JS"],"title":"JavaScript面试（基础）","uri":"/javascript%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98%E5%9F%BA%E7%A1%80/"},{"categories":["interview"],"content":"Promise Promise中then的调用 用一个例子来搞懂，把这个记住应该就没问题了 const p = new Promise((resolve, reject) =\u003e { console.log(\"a\"); resolve(); console.log(\"b\"); }); setTimeout(() =\u003e console.log(\"c\"), 0); p.then(console.log(\"d\")); p.then(() =\u003e console.log(\"e\")); console.log(\"f\"); 问输出顺序？ #card 答案：abdfec 要注意的点 可以把p.then(()=\u003eXXX）看作一个setTimeout(()=\u003eXXX,0)，它是异步调用回调函数的。并且**优先级高于setTimeout(()=\u003eXXX,0) 其他的没什么好注意的了 ^1679408153220 加载脚本Promise改写 ## 浏览器 \\### 加载文档 ","date":"2023-03-21","objectID":"/javascript%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98%E5%9F%BA%E7%A1%80/:4:0","tags":["JS"],"title":"JavaScript面试（基础）","uri":"/javascript%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98%E5%9F%BA%E7%A1%80/"},{"categories":["workflow"],"content":"基于 obsidian 与 hugo 的 obsidian 博客工作流 其实内容还是比较简单的，这里写的话主要是做一个记录。 ","date":"2023-03-14","objectID":"/obsidian_to_hugo-workflow/:0:0","tags":["tools"],"title":"obsidian_to_hugo workflow","uri":"/obsidian_to_hugo-workflow/"},{"categories":["workflow"],"content":"obsidian ","date":"2023-03-14","objectID":"/obsidian_to_hugo-workflow/:1:0","tags":["tools"],"title":"obsidian_to_hugo workflow","uri":"/obsidian_to_hugo-workflow/"},{"categories":["workflow"],"content":"下载 pandoc 导出插件 社区插件中下载，能将 md 格式导出为支持 hugo 的 markdown 格式。 选择 hugo 中的post/ 文件夹作为默认导出位置，十分方便。 ","date":"2023-03-14","objectID":"/obsidian_to_hugo-workflow/:1:1","tags":["tools"],"title":"obsidian_to_hugo workflow","uri":"/obsidian_to_hugo-workflow/"},{"categories":["workflow"],"content":"templatr 生成模版 这里主要是根据 hugo 的默认的 metadata 来调整模版，一个例子 想在 ob 中写 blog 直接导入就可以了，很快捷。 ","date":"2023-03-14","objectID":"/obsidian_to_hugo-workflow/:1:2","tags":["tools"],"title":"obsidian_to_hugo workflow","uri":"/obsidian_to_hugo-workflow/"},{"categories":["workflow"],"content":"hugo 导入后 git 同步就可以了。 ","date":"2023-03-14","objectID":"/obsidian_to_hugo-workflow/:2:0","tags":["tools"],"title":"obsidian_to_hugo workflow","uri":"/obsidian_to_hugo-workflow/"},{"categories":["archive"],"content":"记录一些开发用的网站 ","date":"2023-02-21","objectID":"/web_tool/:1:0","tags":["tool"],"title":"Web_tool","uri":"/web_tool/"},{"categories":["archive"],"content":"软件开发 使用方法 snyk,一个包的类似论坛？ 有 js，python，go 几乎所有的开源包的介绍和分析，很强大。 这个有 github 中某个方法的代码片段，就有点像 英语的 语料库一样。 Snyk Open Source Advisor | Snyk ","date":"2023-02-21","objectID":"/web_tool/:1:1","tags":["tool"],"title":"Web_tool","uri":"/web_tool/"},{"categories":["draft"],"content":"strat the project npx create-next-app nft-marketplace –typescript Use the tailwind Install Tailwind CSS with Next.js - Tailwind CSS: https://tailwindcss.com/docs/guides/nextjs ","date":"2023-02-20","objectID":"/react-ts-solidity-nftmarket/:1:0","tags":["draft"],"title":"React+TS+Solidity+NftMarket","uri":"/react-ts-solidity-nftmarket/"},{"categories":["draft"],"content":"Web3 Provider npm install ethers @metamask/providers A Provider is an abstraction of a connection to the Ethereum network, providing a concise, consistent interface to standard Ethereum node functionality. Providers 提供钱包接口服务 Getting Started ","date":"2023-02-20","objectID":"/react-ts-solidity-nftmarket/:2:0","tags":["draft"],"title":"React+TS+Solidity+NftMarket","uri":"/react-ts-solidity-nftmarket/"},{"categories":["draft"],"content":"Ganache Truffle 本地部署以太网 把这个看一遍基本就明白了 Truffle quickstart - Truffle Suite oppenzepplin/contracts Secure Smart Contract library for Solidity npm install @openzeppelin/contracts ","date":"2023-02-20","objectID":"/react-ts-solidity-nftmarket/:3:0","tags":["draft"],"title":"React+TS+Solidity+NftMarket","uri":"/react-ts-solidity-nftmarket/"},{"categories":["draft"],"content":"react custom hooks SWR “stale-while-revalidate” Why You Should Use React Query or SWR - This Dot Labs React Hooks for Data Fetching – SWR SWR：最具潜力的 React Hooks 数据请求库 - 知乎 ","date":"2023-02-20","objectID":"/react-ts-solidity-nftmarket/:4:0","tags":["draft"],"title":"React+TS+Solidity+NftMarket","uri":"/react-ts-solidity-nftmarket/"},{"categories":["QA-test"],"content":"Agile Manifesto ","date":"2023-02-17","objectID":"/basic_of_agiles/:1:0","tags":["Agile","QA-test"],"title":"Basic of Agiles \u0026 Agile Testing","uri":"/basic_of_agiles/"},{"categories":["QA-test"],"content":"Agile 4 Values individuals and interactions over processes and tools. Working software over comprehensive documentation Customer collaboration over contract negotiation. Responding to change over following a plan. ","date":"2023-02-17","objectID":"/basic_of_agiles/:1:1","tags":["Agile","QA-test"],"title":"Basic of Agiles \u0026 Agile Testing","uri":"/basic_of_agiles/"},{"categories":["QA-test"],"content":"Agile 12 principles Our highest priority is to satisfy the customer through early and continuous delivery of valuable software. Welcome changing requirements, even late in development. Agile processes harness change for the customer’s competitive advantage. Deliver working software frequently, from a couple of weeks to a couple of months, with a preference to the shorter timescale.(one week to three months) Business people and developers must work together daily throughout the project.(work together!) Build projects around motivated individuals. Give them the environment and support they need, and trust them to get the job done. The most efficient and effective method of conveying information to and within a development team is face-to-face conversation. Working software is the primary measure of progress. Agile processes promote sustainable development. The sponsors, developers, and users should be able to maintain a constant pace indefinitely. Continuous attention to technical excellence and good design enhances agility. Simplicity–the art of maximizing the amount of work not done–is essential.(!!!!) The best architectures, requirements, and designs emerge from self-organizing teams. At regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behavior accordingly. ","date":"2023-02-17","objectID":"/basic_of_agiles/:1:2","tags":["Agile","QA-test"],"title":"Basic of Agiles \u0026 Agile Testing","uri":"/basic_of_agiles/"},{"categories":["flutter"],"content":"感觉 flutter 真的好优雅啊，跨平台，随时随地开发应用。 想的是这里建一个 todo List 来 track flutter 的学习记录。 start date #date170223 阅读 flutter 官网文档 ","date":"2023-02-17","objectID":"/%E5%A5%BD%E6%83%B3%E5%AD%A6flutter/:0:0","tags":["flutter"],"title":"好想学Flutter啊","uri":"/%E5%A5%BD%E6%83%B3%E5%AD%A6flutter/"},{"categories":null,"content":"Nice to see you here. ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"About Me","uri":"/about/"},{"categories":null,"content":" This documentation records some common questions and answers, mainly from GitHub Discussions. How to switch Hugo environments? Default environments are development with hugo server and production with hugo. Due to limitations in the local development environment, the comment system, CDN and fingerprint will not be enabled in the development environment. You could enable these features with hugo server -e production. Question Question Didn’t find your questions? Join the discussions. ","date":"2019-08-02","objectID":"/help/:0:0","tags":null,"title":"Help Center","uri":"/help/"},{"categories":null,"content":"offline cache page of FixIt theme","date":"0001-01-01","objectID":"/offline/","tags":null,"title":"","uri":"/offline/"},{"categories":null,"content":"Friends template demo of FixIt theme","date":"0001-01-01","objectID":"/friends/","tags":null,"title":"Friends","uri":"/friends/"},{"categories":null,"content":" Add your FixIt site You could add your FixIt site to this page in nickname lexicographical order via making a PR or editing data , the format is as follows: - nickname: \u003cyour nickname\u003e avatar: \u003cyour avatar\u003e url: \u003cyour site link\u003e description: \u003cdescription of your site\u003e  Website failure, stop maintenance and improper content may be unlinked! ","date":"0001-01-01","objectID":"/friends/:0:0","tags":null,"title":"Friends","uri":"/friends/"},{"categories":["draft"],"content":"引子 在掘金上看到了这篇文章，感觉还蛮有意思的，试试看能不能解决。 面试了十几个高级前端，竟然连（扁平数据结构转 Tree）都写不出来 - 掘金 输入： let arr = [ { id: 1, name: \"部门1\", pid: 0 }, { id: 2, name: \"部门2\", pid: 1 }, { id: 3, name: \"部门3\", pid: 1 }, { id: 4, name: \"部门4\", pid: 3 }, { id: 5, name: \"部门5\", pid: 4 }, ]; 输出： [ { \"id\": 1, \"name\": \"部门1\", \"pid\": 0, \"children\": [ { \"id\": 2, \"name\": \"部门2\", \"pid\": 1, \"children\": [] }, { \"id\": 3, \"name\": \"部门3\", \"pid\": 1, \"children\": [ ]}]} ] 解决 ","date":"0001-01-01","objectID":"/%E6%89%81%E5%B9%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%ACtree/:0:0","tags":["draft"],"title":"扁平结构转Tree","uri":"/%E6%89%81%E5%B9%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%ACtree/"},{"categories":["draft"],"content":"思路 1 循环每一个 id，然后对每一个 id 查找 pid，复杂度 O($N^2$) 这样可以吗？ 答案是不行的，要注意，这里每一个 parent 节点是可以有多个子节点的，子节点又是可以作为新的父母节点的。 在进一步思考这个问题前，回忆 深拷贝的代码 function clone(o) { var temp = {}; for (var key in o) { if (typeof o[key] == \"object\") { temp[key] = clone(o[key]); } else { temp[key] = o[key]; } } return temp; } 我们不难发现，这道题的 本质就是深拷贝！！ 只不过需要将深拷贝中的 if 判断换成寻找 pid。 搞清楚这个后，代码就很容易写出来了。 ","date":"0001-01-01","objectID":"/%E6%89%81%E5%B9%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%ACtree/:1:0","tags":["draft"],"title":"扁平结构转Tree","uri":"/%E6%89%81%E5%B9%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BD%ACtree/"}]